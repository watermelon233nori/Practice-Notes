# 对 OI Wiki 的 MSD 基数排序的 C++ 代码的逐步分析

~~由于本人拙劣的阅读能力，我对着它写的原理和算法流程看实在没看懂，选择尝试分析一下它写的代码。看的是按自然数排序的代码。~~

正因为本人拙劣的能力，发现解读有点花时间，可能单纯我想的有问题，此分析暂且搁置。

## 定义

### Using

|Lvalue|Rvalue|注释|位宽|
|:-----|-----:|---|---|
|u32|uint32_t|无符号 32 位整型|32|
|u64|uint64_t|无符号 64 位整型|64|
|u32ptr|u32*|无符号 32 位整型的指针|64|
|node|tuple<u32ptr, u32ptr, u32>|如 Rvalue 尖括号中包含的类型的元组|160|

### 常量

|数据类型|变量名|十进制|十六进制|原赋值式|
|:------|:-----|:----|------:|-------:|
|u32|maxlogW|32|0000 0100||
|u64|maxW|2147483648|0000 0001 0000 0000|`(u64)`1 << `maxlogW`|
|u32|logW|8|0000 0008||
|u32|W|16|0000 0010|1 << `logW`|
|u32|mask|15|0000 000F|`W` - 1|

## 步骤

先拿到 `u32` 数组的头尾指针先：`first`、`last`。

在堆内存上开一块大小为 ((`last` - `first`) × `4`) 字节的临时内存 `tmp`，置零。

开一个以 `vector<node>` 为基的 `node` 的 `stack` 容器（`stack<node, vector<ndoe>>`）`s`，推入第一个元组，其元组为 {`first`, `last`, `sizeof(u32)` = 4}。

接下来开始如下循环，直到栈容器 `s` 清空。

---

* 预备工作：

    * 定义两个 `u32ptr`：`begin`，`end`

    * 定义一个 `u32`：`shift`

    * 定义一个 `size_t`：`length`

    * 用 `tie` 函数从 `s` 栈顶的元组中三个元素分别拆进 `begin`、`end`、`shift`

    * `length` 赋值为 `end` - `begin`，然后把栈顶元组弹掉。

    * 若 `begin` + 1 >= `end`，则跳过下面的工作，进入下一次循环。

    * 写一个 `key` 函数，参数为两个常数 `u32`，分别为 `x` `shift`，返回这样的值：

        * 将 `x` 向右位移 `shift` 位的值与 `mask` (0x0000 000F) 按位与。

开始计数排序。开 `W` (16) 大的空 `u32` 数组 `cnt`。
